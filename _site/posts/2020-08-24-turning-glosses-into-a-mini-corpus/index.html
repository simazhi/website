<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Thomas Van Hoey">
<meta name="dcterms.date" content="2020-08-24">

<title>Turning glosses into a mini corpus – Thomas Van Hoey</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Thomas Van Hoey</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-researching" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Researching</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-researching">    
        <li>
    <a class="dropdown-item" href="../../STILL NEED TO ADD">
 <span class="dropdown-text">Borrowing iconic words (2024-2027)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../STILL NEED TO ADD">
 <span class="dropdown-text">Grammatical alternation and relative complexity (2023-2024)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../STILL NEED TO ADD">
 <span class="dropdown-text">Transmitting ideophones (2021-2022)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../STILL NEED TO ADD">
 <span class="dropdown-text">Chinese Ideophone Database (2017-2020)</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../STILL NEED TO ADD">
 <span class="dropdown-text">Prototypicality of ideophones (2015-2020)</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../STILL NEED TO ADD"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../STILL NEED TO ADD"> 
<span class="menu-text">Supervising</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../STILL NEED TO ADD"> 
<span class="menu-text">Reviewing</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blogging</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../archive.html"> 
<span class="menu-text">Archiving</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../STILL NEED TO ADD"> 
<span class="menu-text">short CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.thomasvanhoey.com/cv/cv_thomas.pdf"> 
<span class="menu-text">full CV</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../blog.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Turning glosses into a mini corpus</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Yami</div>
                <div class="quarto-category">R</div>
                <div class="quarto-category">rstats</div>
                <div class="quarto-category">corpus</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Thomas Van Hoey </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 24, 2020</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#glossing" id="toc-glossing" class="nav-link active" data-scroll-target="#glossing">Glossing</a></li>
  <li><a href="#yami" id="toc-yami" class="nav-link" data-scroll-target="#yami">Yami</a></li>
  <li><a href="#preprocessing" id="toc-preprocessing" class="nav-link" data-scroll-target="#preprocessing">Preprocessing</a></li>
  <li><a href="#from-source-txt-to-dataframe" id="toc-from-source-txt-to-dataframe" class="nav-link" data-scroll-target="#from-source-txt-to-dataframe">From source txt to dataframe</a></li>
  <li><a href="#finding-furthering-and-outputting" id="toc-finding-furthering-and-outputting" class="nav-link" data-scroll-target="#finding-furthering-and-outputting">Finding, furthering and outputting</a></li>
  <li><a href="#benefits" id="toc-benefits" class="nav-link" data-scroll-target="#benefits">Benefits</a></li>
  <li><a href="#addendum" id="toc-addendum" class="nav-link" data-scroll-target="#addendum">Addendum</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><img src="yami.jpg" class="img-fluid"></p>
<section id="glossing" class="level1">
<h1>Glossing</h1>
<p><a href="https://en.wikipedia.org/wiki/Interlinear_gloss">Glossing</a> is part and parcel in linguistics. Part of our training is learning to represent linguistic data in a format that can be understood by all. An example can be found in below, taken from the <a href="https://www.eva.mpg.de/lingua/pdf/Glossing-Rules.pdf">Leipzig Glossing Rules</a>. In general, morphemes should correspond, being marked by a hyphen or space to separate them, depending on boundedness. The details are highly dependent on your subfield and your audience. For instance, ‘1PL’ (first plural pronoun) could also be represented by ‘we’ in certain contexts. On other occasions, categories of the language you’re studying are not included in the standard Leipzig Glossing Rules set, e.g., ‘ideophone’ can be represented by IDEO, IDPH, etc. There’s also recent advances in the glossing standards of, for instance, <a href="https://wikis.hu-berlin.de/interlinear_glossing/Main_Page">ancient languages</a>, like <a href="http://wwwuser.gwdg.de/~dwernin/published/DiBiase_Kammerzell_Werning-2009-Glossing_Ancient_Egyptian.pdf">this paper by DiBiase et al.</a> for Ancient Egyptian; it’s worth a read. (Bonus: check out the article on <a href="https://en.wikipedia.org/wiki/Kanbun">Kanbun</a> which provides a short intro to how the Japanese marked up Classical Chinese to make sense of it.)</p>
<pre><code>original:         My  s    Marko poexa-l-i avtobus-om v   Peredelkino. 
morphemes:        1PL COM  Marko go-PST-PL bus-INS    ALL Peredelkino
free translation: 'Marko and I went to Perdelkino by bus.'</code></pre>
</section>
<section id="yami" class="level1">
<h1>Yami</h1>
<p>Yesterday, my partner <a href="https://www.researchgate.net/profile/Chun_Jan_Young">CJ Young (UCSB)</a>, who is working with <a href="https://en.wikipedia.org/wiki/Yami_language">Yami (Tao)</a> data and has been <del>pushed somewhat aggresively by me to adopt R and Rmarkdown</del> gradually easing into the R ecoverse, raised an interesting question: <strong>how can I turn my fieldwork glosses into a corpus that’s easily searchable?</strong> Just to clarify things, in his fieldwork he’s following a format that rests on splitting recordings into <a href="https://en.wikipedia.org/wiki/Prosodic_unit">intonation units</a> with the goal of depositing data in the <a href="https://www.researchgate.net/publication/269805639_NTU_corpus_of_Formosan_languages_A_state-of-the-art_report">Corpus of Formosan Languages</a>. However, the data is not in that corpus yet, and mostly written down in .pages (the word of mac os). The usage of .pages is not a requirement, but just a consequence of him working together with <a href="https://manoa-hawaii.academia.edu/GregVondiziano">Greg Vondiziano (UH)</a> and their both having macbooks ha.</p>
<p>A typical gloss looks like this:</p>
<pre><code>1.
ko       ononongan  a    kavavatanen            ya        am, 
ko       ononong-an a    ka-va~vata-nen         ya        am 
1SG.GEN  narrate-LV LK   NMZ-RDPL~hearsay-PV    DEM.PROX  TOP 
1SG.屬格 述說-處焦  繫詞 名物化-重疊～據說-受焦 指示.近距 主題 

ko       nimacita             do
ko       ni-ma-cita           do
1SG.GEN  PFV-PV.able-see      LOC
1SG.屬格 完成貌-受焦.能力-看  處格

2.
paciracirayin an
pa-cira~ciray-in an
CAU-RDPL~light-PV FP
使役-重疊～照亮-受焦 語助詞

#e The story I’m going to tell is what I saw in a movie
#c 我要說的故事是，我在電影上看到的
#n paciracirayin = 電影; ciray = 亮; cirayin = 照</code></pre>
<p>So first there is the gloss number, followed by the original sentence, then an extra level containing the underlying form, then the morphemic glosses in English, in Chinese, and then a free translation of a considerable translation in English (#e) as well as Chinese (#c), and possibly some notes (#n). You can see that there is some structure in the order of these items. But there are also a few annoying things: the first intonation unit has a very long line, which has been split in two (starting with <em>ko</em>); and the translations in #e and #c are metioned for intonation unit 2, but actually also relate to intonation unit 1.</p>
<p>Ideally, corpora become more machine-searchable if they are further standardized. So, I tried to put my head to it and this is what I came up (taking full inspiration from the ASBC corpus used in my PhD dissertation):</p>
<ul>
<li>.txt source files (because lightweight and cross-platform)</li>
<li>script to turn them into dataframe, enabling the powerfull search functions of R (or python)</li>
</ul>
<p>So the goal is to transform the previous into a table with the following columns:</p>
<ul>
<li>intonation unit number *surface</li>
<li>underlying</li>
<li>english morphemes</li>
<li>chinese morphemes</li>
<li>english translation</li>
<li>chinese trans</li>
<li>notes</li>
</ul>
</section>
<section id="preprocessing" class="level1">
<h1>Preprocessing</h1>
<p>As always, I started out with making <a href="https://github.com/simazhi/yamicorpusr">a github repository</a>, to detail the different steps. Next I thought about we were going to get from the source text in .pages to .txt to dataframe. In the preprocessing stages, there are about five things that needed to be checked (manually, just to make sure).</p>
<ol type="1">
<li>Copy into a txt document. Yes, this is easy.</li>
<li>Replace <tabs> with <space>. In a text editor like Atom or even the general text editor on your computer, you can generally replace <code>\t</code> (tab) with <code>\s</code> (space) if regular expressions are enabled.</space></tabs></li>
<li>Check all multi line glosses on one line. This needs to be checked manually, just to make sure.</li>
<li>Add the following. You need to tag the lines, they can be in different orders (maybe one document has the Chinese line before the English line), but they need to be identified. Ideally this can be done programmatically, but better safe with manual than sorry with computational.
<ol type="1">
<li>‘s’ to surface line</li>
<li>‘u’ to underlying line</li>
<li>‘e’ to English gloss</li>
<li>‘z’ to Chinese gloss</li>
</ol></li>
<li>Replace all <code>\n\n+</code> with <code>\n</code>. This regular expression will delete empty lines.</li>
</ol>
<p>Should people be reading this and have tips on to make this more efficient, always welcome.</p>
<p><strong>UPDATE</strong> After thinking about it for a while, adding the SUEZ (strategic acronym for the tagging system), the following regular expressions should do the trick.</p>
<pre><code>(\d\.\n)      replace by `$1s ` (s followed by space) # S
(^s [^\n]+\n) replace by `$1u ` (u followed by space) # U
(^u [^\n]+\n) replace by `$1e ` (e followed by space) # E
(^e [^\n]+\n) replace by `$1z ` (z followed by space) # Z</code></pre>
</section>
<section id="from-source-txt-to-dataframe" class="level1">
<h1>From source txt to dataframe</h1>
<p>For this you need the following packages</p>
<pre><code>library(tidyverse) # collection of tools
library(here) # best practice project management
library(fs) # optional here but preparing for many docs later
library(glue) # will need later</code></pre>
<p>Next read in the source text that is somewhere in your R project. Learn the <code>here</code> package if you don’t know how that works.</p>
<pre><code>readin &lt;- read_lines(here("SOURCETEXT.txt"))</code></pre>
<p>What you get is a vector, called <code>readin</code>, containing every line as a piece of data, something like this:</p>
<pre><code>[1] 1.
[2] s ko ononongan a kavavatanen ya am, ko nimacita do
[3] u ko ononong-an a ka-va~vata-nen ya am ko ni-ma-cita do
[4] e 1SG.GEN narrate-LV LK NMZ-RDPL~hearsay-PV DEM.PROX TOP 1SG.GEN PFV-PV.able-see LOC
[5] z 1SG.屬格 述說-處焦 繫詞 名物化-重疊～據說-受焦 指示.近距 主題 1SG.屬格 完成貌-受焦.能力-看 處格</code></pre>
<p>Next, we need to transform this into the aforementioned table format.</p>
<pre><code>tableform &lt;- # declaring the output variable
readin %&gt;% # take readin and then
  as_tibble() %&gt;%  # turn it into a fance tibble
  
  # tagging (making columns)
  mutate(linenumber = cumsum(str_detect(value, "\\d\\."))) %&gt;% 
  mutate(category = str_extract(value, "^..?(?=\\s)")) %&gt;% 
  
  # spreding wider
  pivot_wider(names_from = "category", values_from = "value") %&gt;%
  
  # fill out the missing translations
  fill(`#e`, .direction = "up") %&gt;% 
  fill(`#c`, .direction = "up") %&gt;% 
  
  # beautify
  select(-`NA`) %&gt;% 
  rename(surface = s,
         underlying = u,
         englishgloss = e,
         chinesegloss = z,
         englishtrans = `#e`,
         chinesetrans = `#c`) %&gt;% 
         
  # delete the tags 's' 'u' 'e' 'z' as well as #n #c #e
  mutate(across(where(is.character), 
                ~str_remove(.x, "^..?\\s")))</code></pre>
<p>And tadaah, the table for this text is ready and can be queried.</p>
</section>
<section id="finding-furthering-and-outputting" class="level1">
<h1>Finding, furthering and outputting</h1>
<p>Let’s say, you want to find all OBL markers, to see if there is any variation. A simple search can be done with <code>dplyr::filter</code> and <code>str_detect</code>.</p>
<pre><code>tableform %&gt;%
  filter(str_detect(englishgloss, "OBL"))</code></pre>
<p>Or you can select a number of columns of interest and integrate it with a <code>tidytext::unnest_tokens</code> pipeline (or cast to other corpus packages), for instance, if you want to make a dictionary of a certain kind (which can then be used to pretag new texts for which you have the surface form or underlying form).</p>
<p>For exploratory output, I would suggest to use the <code>glue</code> package, as it is extremely customisable. Two immediate output formats that come to mind are 1) something closer to what it originally was in .pages, 2) output to be used in the fantastic LaTeX package <code>expex</code>.</p>
<p>The syntax of <code>glue</code> is extremely simple. The following will take everything you have and output it in (here in Rmarkdown) in nice text lines. What then needs to happen when you copy to other programs, is to beautify it, and split long lines again on multiple lines.</p>
<pre><code>glue('{tableform$linenumber}
     {tableform$surface}
     {tableform$underlying}
     {tableform$englishgloss}
     {tableform$chinesegloss}
     {tableform$englishtrans}
     {tableform$chinesetrans}
     
     ')</code></pre>
<p>But if you’re writing in Rmarkdown or LaTeX, you can easily customize this in such a way that it preformats into the <code>expex</code> format (without having to worry about the multiline glosses or spacing because that’s what expex does!):</p>
<pre><code>glue('\ex[glstyle=wrap]
     \begingl
     \gla {tableform$surface} //
     \glb {tableform$underlying} //
     \glc {tableform$englishgloss} //
     \glft {tableform$englishtrans} //
     \endgl
     \xe')</code></pre>
</section>
<section id="benefits" class="level1">
<h1>Benefits</h1>
<p>The general benefits of having this set up is easy exploration of your data; no longer do you need to open up each .pages document and manually count how many times a certain thing occurs. What is also good is that it keeps reference numbers, so you can always go back to the source. It is a flexible setup, in that if you have a special tag format, for instance a #j for Japanese translation or so, this will automatically be capture in the table. And if you are used to marking the voice system with a V instead of F for focus, then you can implement that easily in R.</p>
<p>What does still need to happen, however, is a metadata file that links the source texts to data on the speaker, but that is just good housekeeping. So probably not the last update on this miniproject, but a good start. Good luck CJ!</p>
</section>
<section id="addendum" class="level1">
<h1>Addendum</h1>
<p>After posting about this blog update on facebook, Shu-Kai Hsieh pointed me into the direction of Yongfu Liao’s app version for when they did fieldwork last year, <a href="https://glosss.yongfu.name/#/">which can be found here</a>. It’s a beautiful app, and it basically starts from a similar position as this project. It shows very clearly when there are differing glosses, allowing the annotator to standardize the glosses. It also goes beyond my approach by doing the exact dictionary style matching between forms and gloss I mentioned before, which I would implement with <code>tidytext</code>, and it provides a nice quick and dirty look up possibility, shown here when looking for ‘OBL’ (oblique).</p>
<p><img src="rukaigloss.png" class="img-fluid"></p>
<p>The points I have some reservations about, however, are (1) that the <a href="https://yongfu.name/gloss-search/2020_Budai_Rukai.log">log</a> shows that there are incongruencies between the different columns. (2) The <a href="https://github.com/liao961120/gloss-search/">input format</a> (shown below) requires that the glosses are aligned, but I think that is epiphenomenal – one space is all I would want. (3) Fundamentally, while this app is beautiful and useful if you have only a bit of data, it does not enable the user to quickly count a given phenomenon, e.g., the frequency of OBL. And this was the kind of question that CJ asked me. So I think there is room for growth in Yongfu’s app, but also inspiration for the way I approached it.</p>
<pre><code>[編號].
[族語轉寫 (原始, optional)]
[空行 (optional)]
[族語分析 (aligned)]
[英文Glossing (aligned)]
[中文Glossing (aligned)]
[空行]
#e [英文翻譯]
#c [中文翻譯]
#n [註釋]
[空行]</code></pre>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/thomasvanhoey\.com");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>